podatki.plot$na.3<- 1 #za risanje grafa
podatki.plot[set.na.3, "na.3"] <- 4
podatki.plot$na.4<- 1 #za risanje grafa
podatki.plot[set.na.4, "na.4"] <- 4
#return(podatki.plot)
p1 <- plot(podatki.plot$X1, podatki.plot$X2, col = podatki.plot$na.2,
main = "Povezanost med spremenljivko X1 \n in manjkajocimi podatki X2",
xlab = "X1", ylab = "X2")
legend("bottomright", legend = c("obstojeci", "manjkajoci"), col= c(1,4), pch = 1)
p2 <- plot(podatki.plot$X1, podatki.plot$X3, col = podatki.plot$na.3,
main = "Povezanost med spremenljivko X1 \n in manjkajocimi podatki X3",
xlab = "X1", ylab = "X3")
legend("bottomright", legend = c("obstojeci", "manjkajoci"), col= c(1,4), pch = 1)
p3 <- plot(podatki.plot$X1, podatki.plot$X4, col = podatki.plot$na.4,
main = "Povezanost med spremenljivko X1 \n in manjkajocimi podatki X4",
xlab = "X1", ylab = "X4")
legend("bottomright", legend = c("obstojeci", "manjkajoci"), col= c(1,4), pch = 1)
return(list(podatki, p1,p2,p3))
}
else{
return(podatki)
}
}
nmar.ft <- get.data.NMAR(moc.mehanizma = 10, prop.NA = 0.5, plot= T)
df <- get.data.NMAR(moc.mehanizma = 10, prop.NA = 0.5)
apply(df,2, function(x) sum(is.na(x)))
library(ImputacijeRZM)
get.data.NMAR
# # poglej stevilo jedr in odstej enega (za nase delo)
no_cores <- detectCores() - 1
#
# # doloci "skupine" za delo
cl <- makeCluster(no_cores)
#
# # registriraj "parallel beckend"
registerDoParallel(cl)
system.time(
rez <- foreach(i = 1:nrow(zasnova), .combine = "rbind",
.packages = c("MASS", "mice", "missForest", "fpc", "DescTools",
"DMwR", "missForest", "ImputacijeRZM", "pastecs", "norm")) %dorng% {
df <- get.data.NMAR(300, zasnova[i, "delez_na"])
df.test <- get.data.MCAR(1000, 0)
rf <- lda_rf(df, df.test)
em <- EM.algoritem(df, df.test)
knn <- lda_knn(df, df.test, 10)
mice <- lda_mice(df, df.test, 10)
cbind(zasnova[i,], "rf" = rf$prop, "em" = em, "knn" = knn, "mice" = mice$prop)
})
df <- get.data.NMAR(300, zasnova[i, "delez_na"])
df.test <- get.data.MCAR(1000, 0)
rf <- lda_rf(df, df.test)
em <- EM.algoritem(df, df.test)
knn <- lda_knn(df, df.test, 10)
mice <- lda_mice(df, df.test, 10)
cbind(zasnova[i,], "rf" = rf$prop, "em" = em, "knn" = knn, "mice" = mice$prop)
i
stopCluster(cl)
registerDoSEQ()
pon <- 5
sampleSize <- 300
stSpremenljivk <- 4
delez_na <- c(0.3, 0.4, 0.5, 0.6)
zasnova <- expand.grid(delez_na, sampleSize, stSpremenljivk)
zasnova <- do.call(rbind, replicate(pon, zasnova, simplify=FALSE)) %>% `colnames<-`(c("delez_na", "N", "n_skupin"))
system.time(
rez <- foreach(i = 1:nrow(zasnova), .combine = "rbind",
.packages = c("MASS", "mice", "missForest", "fpc", "DescTools",
"DMwR", "missForest", "ImputacijeRZM", "pastecs", "norm")) %dorng% {
df <- get.data.NMAR(300, zasnova[i, "delez_na"])
df.test <- get.data.MCAR(1000, 0)
rf <- lda_rf(df, df.test)
em <- EM.algoritem(df, df.test)
knn <- lda_knn(df, df.test, 10)
mice <- lda_mice(df, df.test, 10)
cbind(zasnova[i,], "rf" = rf$prop, "em" = em, "knn" = knn, "mice" = mice$prop)
})
?foreach
dim(zasnova)
df <- get.data.NMAR(300, zasnova[i, "delez_na"])
df.test <- get.data.MCAR(1000, 0)
rf <- lda_rf(df, df.test)
em <- EM.algoritem(df, df.test)
knn <- lda_knn(df, df.test, 10)
mice <- lda_mice(df, df.test, 10)
mice <- lda_mice(df, df.test, 10)
lda_mice(df, df.test)
lda_mice(df, df.test, 10)
miss_df <- df
m <- 10
#Imputiram manjkajoče vrednosti z mice
imp <- mice(miss_df, m = m, printFlag = FALSE)
head(imp)
#shranimo vsa imp. podatkovja v long format
imp_tot <- complete(imp, "long", include = TRUE)
post_tot <- NULL
for(i in 1:m){
mod <- lda(skupina ~ X1 + X2 + X3 + X4, imp_tot[(i-1)*nrow(miss_df)+1:((i-1)*nrow(miss_df)+nrow(miss_df)),])
post <- predict(mod, test_df[,1:4])$posterior
post_tot <- rbind(post_tot, post)
}
post_tot <- as.data.frame(post_tot)
test_df <- df.test
post_tot <- NULL
for(i in 1:m){
mod <- lda(skupina ~ X1 + X2 + X3 + X4, imp_tot[(i-1)*nrow(miss_df)+1:((i-1)*nrow(miss_df)+nrow(miss_df)),])
post <- predict(mod, test_df[,1:4])$posterior
post_tot <- rbind(post_tot, post)
}
post_tot <- as.data.frame(post_tot)
head(df)
head(df.test)
dim(df)
dim(df.test)
i <- 1
mod <- lda(skupina ~ X1 + X2 + X3 + X4, imp_tot[(i-1)*nrow(miss_df)+1:((i-1)*nrow(miss_df)+nrow(miss_df)),])
post <- predict(mod, test_df[,1:4])$posterior
post_tot <- rbind(post_tot, post)
mod
post
post_tot <- NULL
for(i in 1:m){
mod <- lda(skupina ~ X1 + X2 + X3 + X4, imp_tot[(i-1)*nrow(miss_df)+1:((i-1)*nrow(miss_df)+nrow(miss_df)),])
post <- predict(mod, test_df[,1:4])$posterior
post_tot <- rbind(post_tot, post)
}
post_tot <- as.data.frame(post_tot)
rbind(...)
dim(post)
dim(post_tot)
post_tot <- NULL
mod <- lda(skupina ~ X1 + X2 + X3 + X4, imp_tot[(i-1)*nrow(miss_df)+1:((i-1)*nrow(miss_df)+nrow(miss_df)),])
post <- predict(mod, test_df[,1:4])$posterior
dim(post)
head(post)
post_tot <- rbind(post_tot, post)
head(post_tot)
post_tot <- NULL
for(i in 1:m){
mod <- lda(skupina ~ X1 + X2 + X3 + X4, imp_tot[(i-1)*nrow(miss_df)+1:((i-1)*nrow(miss_df)+nrow(miss_df)),])
post <- predict(mod, test_df[,1:4])$posterior
post_tot <- rbind(post_tot, post)
}
head(imp_tot)
system.time(
rez <- foreach(i = 1:nrow(zasnova), .combine = "rbind",
.packages = c("MASS", "mice", "missForest", "fpc", "DescTools",
"DMwR", "missForest", "ImputacijeRZM", "pastecs", "norm")) %dorng% {
df <- get.data.MAR(300, zasnova[i, "delez_na"])
df.test <- get.data.MCAR(1000, 0)
rf <- lda_rf(df, df.test)
em <- EM.algoritem(df, df.test)
knn <- lda_knn(df, df.test, 10)
mice <- lda_mice(df, df.test, 10)
cbind(zasnova[i,], "rf" = rf$prop, "em" = em, "knn" = knn, "mice" = mice$prop)
})
melted <- melt(rez,
id.vars = c("delez_na", "N", "n_skupin"),
measure.vars = c("rf", "em", "knn", "mice"))
ggplot(data = melted, mapping = aes(x = delez_na, y = value, group = variable, col = variable)) +
scale_x_continuous(name = "Delez manjkajocih vrednosti") +
scale_y_continuous(name = "Delez pravilno razvrscenih enot") +
stat_summary(fun.y = mean, geom = "point") +
stat_summary(fun.y = mean, geom = "line")
df <- get.data.MAR(300, zasnova[i, "delez_na"])
df.test <- get.data.MCAR(1000, 0)
miss_df <- d.ci()
test_df <- df.test
miss_df <- df
post_tot <- NULL
for(i in 1:m){
mod <- lda(skupina ~ X1 + X2 + X3 + X4, imp_tot[(i-1)*nrow(miss_df)+1:((i-1)*nrow(miss_df)+nrow(miss_df)),])
post <- predict(mod, test_df[,1:4])$posterior
post_tot <- rbind(post_tot, post)
}
lda_mice(df, df.test, 5)
lda_mice(df, df.test, 10)
lda_mice(get.data.NMAR(),get.data.NMAR(1000,0,0), 10)
system.time(
rez <- foreach(i = 1:nrow(zasnova), .combine = "rbind",
.packages = c("MASS", "mice", "missForest", "fpc", "DescTools",
"DMwR", "missForest", "ImputacijeRZM", "pastecs", "norm")) %dorng% {
df <- get.data.MAR(300, zasnova[i, "delez_na"])
df.test <- get.data.MCAR(1000, 0,0)
rf <- lda_rf(df, df.test)
em <- EM.algoritem(df, df.test)
knn <- lda_knn(df, df.test, 10)
mice <- lda_mice(df, df.test, 10)
cbind(zasnova[i,], "rf" = rf$prop, "em" = em, "knn" = knn, "mice" = mice$prop)
})
df.test <- get.data.MCAR(1000, 0,0)
df <- get.data.NMAR(300, zasnova[i, "delez_na"])
df.test <- get.data.NMAR(1000, 0,0)
system.time(
rez <- foreach(i = 1:nrow(zasnova), .combine = "rbind",
.packages = c("MASS", "mice", "missForest", "fpc", "DescTools",
"DMwR", "missForest", "ImputacijeRZM", "pastecs", "norm")) %dorng% {
df <- get.data.NMAR(300, zasnova[i, "delez_na"])
df.test <- get.data.NMAR(1000, 0,0)
rf <- lda_rf(df, df.test)
em <- EM.algoritem(df, df.test)
knn <- lda_knn(df, df.test, 10)
mice <- lda_mice(df, df.test, 10)
cbind(zasnova[i,], "rf" = rf$prop, "em" = em, "knn" = knn, "mice" = mice$prop)
})
head(df)
head(df.test)
dim(df)
dim(df.test)
lda_mice(df, df.test, 5)
for(i in 1:10){
print((i-1)*nrow(miss_df)+1:((i-1)*nrow(miss_df)+nrow(miss_df)))
}
for(i in 1:10){
print((i-1)*nrow(df)+1:((i-1)*nrow(df)+nrow(df)))
}
dim(df)
nrow(df)
for(i in 1:10){
print((i-1)*nrow(df)+1,((i-1)*nrow(df)+nrow(df)))
}
for(i in 1:10){
c((i-1)*nrow(df)+1,((i-1)*nrow(df)+nrow(df)))
}
a <- NULL
for(i in 1:10){
a <- rbind(a, c((i-1)*nrow(df)+1,((i-1)*nrow(df)+nrow(df))))
}
a
source('~/.active-rstudio-document', echo=TRUE)
a
5*999
lda_mice(df, df.test, 5)
post_tot <- NULL
for(i in 1:m){
mod <- lda(skupina ~ X1 + X2 + X3 + X4, imp_tot[(i-1)*nrow(miss_df)+1:((i-1)*nrow(miss_df)+nrow(miss_df)),])
post <- predict(mod, test_df[,1:4])$posterior
post_tot <- rbind(post_tot, post)
}
post_tot <- as.data.frame(post_tot)
dim(post_tot)
dim(post)
colnames(df.test)
dim(imp_tot)
colnames(imp_tot)
head(imp_tot)
a <- NULL
for(i in 1:10){
a <- rbind(a, c((i-1)*nrow(df.test)+1,((i-1)*nrow(df.test)+nrow(df.test))))
}
a
dim(get.data.MAR())
View(df)
apply(df, 2, function(x) sum(is.na(x)/length(x)))
dim(df.test)
df.test <- get.data.NMAR(1000,0,0)
dim(df.test)
View(d.test)
View(df.test)
df.test <- get.data.NMAR(300,0,0)
1000/3
df.test <- get.data.NMAR(1200,0,0)
dim(df.test)
lda_mice(df, df.test, 5)
i
ncol(post_tot)
head(post_tot)
head(post)
tail(post_tot)
View(post_tot)
View(imp_tot)
View(imp_tot[300:600,])
seq(m,1,-1)
lda_knn(df)
lda_knn(df, df.test, 5)
lda_knn(df, df.test, 5)
lda_knn(df, df.test, 5)
lda_mice(df, df.test, 5)
lda_mice <- function(miss_df, test_df, m){
#Imputiram manjkajoče vrednosti z mice
imp <- mice(miss_df, m = m, printFlag = FALSE)
#Pogledam summary imputacij (ce predhodno definiram, da je spr. faktor, mi sam da npr., logisticno regresijo)
#Vidimo imputirane vrednosti iz vseh 5ih podatkovij za sprem X2 -> bi bilo smiselno pogledati konvergenco?
imp$imp$X2
#shranimo vsa imp. podatkovja v long format
imp_tot <- complete(imp, "long", include = TRUE)
# #LDA
# mod_lda <- with(imp, lda(skupina ~ X1 + X2 + X3 + X4))
# lda_class <- predict(mod_lda$analyses[1], podatki[,1:4])$class
#
# m <- 10
# post_tot <- NULL
# for(i in 1:m){
#   mod <- lda(skupina ~ X1 + X2 + X3 + X4, imp_tot[(i-1)*300+1:((i-1)*300+300),])
#   post <- predict(mod, podatki[,1:4])$posterior
#   post_tot <- cbind(post_tot, post)
# }
#
# colnames(post_tot) <- paste(paste("Sk", rep(1:3,m), sep = "_"), rep(1:m, each = 3), sep = "_")
post_tot <- NULL
for(i in seq(m,1,-1)){
mod <- lda(skupina ~ X1 + X2 + X3 + X4, imp_tot[(i-1)*nrow(miss_df)+1:((i-1)*nrow(miss_df)+nrow(miss_df)),])
post <- predict(mod, test_df[,1:4])$posterior
post_tot <- rbind(post_tot, post)
}
post_tot <- as.data.frame(post_tot)
#dodam spremenljivko podatkovje
post_tot[,4] <- as.factor(rep(1:m, each = nrow(test_df)))
#dodam spremenljivko enota
post_tot[,5] <- as.factor(rep(1:nrow(test_df), times = m))
#povprečim verjetnosti po vseh podatkovjih
imp_agg_post <- aggregate(post_tot[,1:3], list(post_tot$V5), mean)
imp_agg_post <- imp_agg_post[,-1]
#določim skupino glede na največjo verjetnost
imp_class <- NULL
for(i in 1:nrow(imp_agg_post)){
class <- if(imp_agg_post[i,1] == max(imp_agg_post[i,])){
1
}else if(imp_agg_post[i,2] == max(imp_agg_post[i,])){
2
} else{3}
imp_class <- c(imp_class,class)
}
#delez pravilno razvrscenih
lda_prop <- mean(imp_class==test_df[,5])
k <- list(m = m, class = imp_class, prop = lda_prop, con_X2 = aggregate(post_tot[,1:3], list(post_tot$V4), mean)[,2],
con_X3 = aggregate(post_tot[,1:3], list(post_tot$V4), mean)[,3],
con_X4 = aggregate(post_tot[,1:3], list(post_tot$V4), mean)[,4])
return(k)
}
lda_mice(df, df.test, 5)
seq(m,1,-1)
lda_mice <- function(miss_df, test_df, m){
#Imputiram manjkajoče vrednosti z mice
imp <- mice(miss_df, m = m, printFlag = FALSE)
#Pogledam summary imputacij (ce predhodno definiram, da je spr. faktor, mi sam da npr., logisticno regresijo)
#Vidimo imputirane vrednosti iz vseh 5ih podatkovij za sprem X2 -> bi bilo smiselno pogledati konvergenco?
imp$imp$X2
#shranimo vsa imp. podatkovja v long format
imp_tot <- complete(imp, "long", include = TRUE)
# #LDA
# mod_lda <- with(imp, lda(skupina ~ X1 + X2 + X3 + X4))
# lda_class <- predict(mod_lda$analyses[1], podatki[,1:4])$class
#
# m <- 10
# post_tot <- NULL
# for(i in 1:m){
#   mod <- lda(skupina ~ X1 + X2 + X3 + X4, imp_tot[(i-1)*300+1:((i-1)*300+300),])
#   post <- predict(mod, podatki[,1:4])$posterior
#   post_tot <- cbind(post_tot, post)
# }
#
# colnames(post_tot) <- paste(paste("Sk", rep(1:3,m), sep = "_"), rep(1:m, each = 3), sep = "_")
post_tot <- NULL
for(i in seq(m,1,-1)){
prvi.indeks <- (i-1)*nrow(miss_df)+1
drugi <- ((i-1)*nrow(miss_df)+nrow(miss_df))
print(c(prvi.indeks, drugi))
mod <- lda(skupina ~ X1 + X2 + X3 + X4, imp_tot[(i-1)*nrow(miss_df)+1:((i-1)*nrow(miss_df)+nrow(miss_df)),])
post <- predict(mod, test_df[,1:4])$posterior
post_tot <- rbind(post_tot, post)
}
post_tot <- as.data.frame(post_tot)
#dodam spremenljivko podatkovje
post_tot[,4] <- as.factor(rep(1:m, each = nrow(test_df)))
#dodam spremenljivko enota
post_tot[,5] <- as.factor(rep(1:nrow(test_df), times = m))
#povprečim verjetnosti po vseh podatkovjih
imp_agg_post <- aggregate(post_tot[,1:3], list(post_tot$V5), mean)
imp_agg_post <- imp_agg_post[,-1]
#določim skupino glede na največjo verjetnost
imp_class <- NULL
for(i in 1:nrow(imp_agg_post)){
class <- if(imp_agg_post[i,1] == max(imp_agg_post[i,])){
1
}else if(imp_agg_post[i,2] == max(imp_agg_post[i,])){
2
} else{3}
imp_class <- c(imp_class,class)
}
#delez pravilno razvrscenih
lda_prop <- mean(imp_class==test_df[,5])
k <- list(m = m, class = imp_class, prop = lda_prop, con_X2 = aggregate(post_tot[,1:3], list(post_tot$V4), mean)[,2],
con_X3 = aggregate(post_tot[,1:3], list(post_tot$V4), mean)[,3],
con_X4 = aggregate(post_tot[,1:3], list(post_tot$V4), mean)[,4])
return(k)
}
lda_mice(df, df.test, 5)
lda_mice <- function(miss_df, test_df, m){
#Imputiram manjkajoče vrednosti z mice
imp <- mice(miss_df, m = m, printFlag = FALSE)
#Pogledam summary imputacij (ce predhodno definiram, da je spr. faktor, mi sam da npr., logisticno regresijo)
#Vidimo imputirane vrednosti iz vseh 5ih podatkovij za sprem X2 -> bi bilo smiselno pogledati konvergenco?
imp$imp$X2
#shranimo vsa imp. podatkovja v long format
imp_tot <- complete(imp, "long", include = TRUE)
# #LDA
# mod_lda <- with(imp, lda(skupina ~ X1 + X2 + X3 + X4))
# lda_class <- predict(mod_lda$analyses[1], podatki[,1:4])$class
#
# m <- 10
# post_tot <- NULL
# for(i in 1:m){
#   mod <- lda(skupina ~ X1 + X2 + X3 + X4, imp_tot[(i-1)*300+1:((i-1)*300+300),])
#   post <- predict(mod, podatki[,1:4])$posterior
#   post_tot <- cbind(post_tot, post)
# }
#
# colnames(post_tot) <- paste(paste("Sk", rep(1:3,m), sep = "_"), rep(1:m, each = 3), sep = "_")
post_tot <- NULL
for(i in seq(m,1,-1)){
prvi.indeks <- (i-1)*nrow(miss_df)+1
drugi <- ((i-1)*nrow(miss_df)+nrow(miss_df))
print(c(prvi.indeks, drugi))
mod <- lda(skupina ~ X1 + X2 + X3 + X4, imp_tot[(i-1)*nrow(miss_df)+1:((i-1)*nrow(miss_df)+nrow(miss_df)),])
post <- predict(mod, test_df[,1:4])$posterior
print(dim(post))
post_tot <- rbind(post_tot, post)
}
post_tot <- as.data.frame(post_tot)
#dodam spremenljivko podatkovje
post_tot[,4] <- as.factor(rep(1:m, each = nrow(test_df)))
#dodam spremenljivko enota
post_tot[,5] <- as.factor(rep(1:nrow(test_df), times = m))
#povprečim verjetnosti po vseh podatkovjih
imp_agg_post <- aggregate(post_tot[,1:3], list(post_tot$V5), mean)
imp_agg_post <- imp_agg_post[,-1]
#določim skupino glede na največjo verjetnost
imp_class <- NULL
for(i in 1:nrow(imp_agg_post)){
class <- if(imp_agg_post[i,1] == max(imp_agg_post[i,])){
1
}else if(imp_agg_post[i,2] == max(imp_agg_post[i,])){
2
} else{3}
imp_class <- c(imp_class,class)
}
#delez pravilno razvrscenih
lda_prop <- mean(imp_class==test_df[,5])
k <- list(m = m, class = imp_class, prop = lda_prop, con_X2 = aggregate(post_tot[,1:3], list(post_tot$V4), mean)[,2],
con_X3 = aggregate(post_tot[,1:3], list(post_tot$V4), mean)[,3],
con_X4 = aggregate(post_tot[,1:3], list(post_tot$V4), mean)[,4])
return(k)
}
lda_mice(df, df.test, 5)
?rbind
a
for(i in 1:10){
a <- rbind(a, c((i)*nrow(df.test)+1,((i)*nrow(df.test)+nrow(df.test))))
}
a
for(i in 1:10){
a <- rbind(a, c((i-1)*nrow(df.test)+1,((i-1)*nrow(df.test)+nrow(df.test))))
}
complete
?complete
lda_mice <- function(miss_df, test_df, m){
#Imputiram manjkajoče vrednosti z mice
imp <- mice(miss_df, m = m, printFlag = FALSE)
#Pogledam summary imputacij (ce predhodno definiram, da je spr. faktor, mi sam da npr., logisticno regresijo)
#Vidimo imputirane vrednosti iz vseh 5ih podatkovij za sprem X2 -> bi bilo smiselno pogledati konvergenco?
imp$imp$X2
#shranimo vsa imp. podatkovja v long format
imp_tot <- complete(imp, "long", include = FALSE)
# #LDA
# mod_lda <- with(imp, lda(skupina ~ X1 + X2 + X3 + X4))
# lda_class <- predict(mod_lda$analyses[1], podatki[,1:4])$class
#
# m <- 10
# post_tot <- NULL
# for(i in 1:m){
#   mod <- lda(skupina ~ X1 + X2 + X3 + X4, imp_tot[(i-1)*300+1:((i-1)*300+300),])
#   post <- predict(mod, podatki[,1:4])$posterior
#   post_tot <- cbind(post_tot, post)
# }
#
# colnames(post_tot) <- paste(paste("Sk", rep(1:3,m), sep = "_"), rep(1:m, each = 3), sep = "_")
post_tot <- NULL
for(i in seq(m,1,-1)){
prvi.indeks <- (i-1)*nrow(miss_df)+1
drugi <- ((i-1)*nrow(miss_df)+nrow(miss_df))
print(c(prvi.indeks, drugi))
mod <- lda(skupina ~ X1 + X2 + X3 + X4, imp_tot[(i-1)*nrow(miss_df)+1:((i-1)*nrow(miss_df)+nrow(miss_df)),])
post <- predict(mod, test_df[,1:4])$posterior
print(dim(post))
post_tot <- rbind(post_tot, post)
}
post_tot <- as.data.frame(post_tot)
#dodam spremenljivko podatkovje
post_tot[,4] <- as.factor(rep(1:m, each = nrow(test_df)))
#dodam spremenljivko enota
post_tot[,5] <- as.factor(rep(1:nrow(test_df), times = m))
#povprečim verjetnosti po vseh podatkovjih
imp_agg_post <- aggregate(post_tot[,1:3], list(post_tot$V5), mean)
imp_agg_post <- imp_agg_post[,-1]
#določim skupino glede na največjo verjetnost
imp_class <- NULL
for(i in 1:nrow(imp_agg_post)){
class <- if(imp_agg_post[i,1] == max(imp_agg_post[i,])){
1
}else if(imp_agg_post[i,2] == max(imp_agg_post[i,])){
2
} else{3}
imp_class <- c(imp_class,class)
}
#delez pravilno razvrscenih
lda_prop <- mean(imp_class==test_df[,5])
k <- list(m = m, class = imp_class, prop = lda_prop, con_X2 = aggregate(post_tot[,1:3], list(post_tot$V4), mean)[,2],
con_X3 = aggregate(post_tot[,1:3], list(post_tot$V4), mean)[,3],
con_X4 = aggregate(post_tot[,1:3], list(post_tot$V4), mean)[,4])
return(k)
}
lda_mice(df, df.test, 5)
